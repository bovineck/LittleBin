<!DOCTYPE html>
<html lang="en" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Analysis: ESP32 Programming Methodologies</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chosen Palette: Warm Neutrals -->
    <!-- Application Structure Plan: A single-page, vertical-scrolling application designed to educate users on programming best practices. The core structure uses a side-by-side comparison layout to directly contrast the "blocking" vs. "non-blocking" approaches from the source report across four key themes. This direct comparison is the most effective way to highlight the differences. The flow starts with the main thesis, moves to detailed comparisons, and concludes with a custom HTML/CSS timeline visualization to visually reinforce the core concept of concurrency. This structure was chosen for its clarity, educational effectiveness, and direct mapping to the comparative nature of the source material. -->
    <!-- Visualization & Content Choices: Report Info: Four points of comparison between two code files. Goal: Educate & Compare. Viz/Presentation: Side-by-side text and code blocks using a two-column grid. Interaction: User scrolls and visually compares the columns. Justification: Direct comparison is the clearest way to present this information. Report Info: The abstract concept of blocking vs. non-blocking task execution. Goal: Visually explain a complex timing concept. Viz/Presentation: A custom timeline diagram built with styled HTML divs and Tailwind CSS. Interaction: Static visual aid. Justification: A visual diagram is more intuitive and impactful for explaining concurrency than text alone. Library/Method: All visuals are created with HTML and Tailwind CSS. No JS libraries like Chart.js are needed as the data is conceptual, not quantitative. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        .task-block {
            transition: all 0.3s ease-in-out;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <div class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">

        <header class="text-center my-8 md:my-12">
            <h1 class="text-3xl sm:text-4xl md:text-5xl font-bold text-slate-900 tracking-tight">Interactive Analysis</h1>
            <p class="mt-4 text-lg text-slate-600 max-w-3xl mx-auto">An exploration of two ESP32 programming methodologies, highlighting why the implementation approach is more critical than the library choice.</p>
        </header>

        <main>
            <section id="crucial-distinction" class="bg-white rounded-2xl shadow-lg p-6 sm:p-8 my-10">
                <h2 class="text-2xl sm:text-3xl font-bold text-center text-slate-900 mb-6">The Crucial Distinction: Library vs. Methodology</h2>
                <p class="text-center text-slate-600 mb-8 max-w-4xl mx-auto">This is the most important concept to understand. While the first code file used a "non-blocking" library, its implementation was fundamentally blocking. Conversely, the second file used a simpler "blocking" library but implemented a brilliant non-blocking methodology, making its overall approach far superior.</p>
                <div class="grid md:grid-cols-2 gap-8">
                    <div class="border border-red-200 bg-red-50 rounded-lg p-6">
                        <h3 class="text-xl font-semibold text-red-800 flex items-center mb-3">
                            <span class="text-2xl mr-3">❌</span> File 1's Problem
                        </h3>
                        <p class="text-red-700">The `ESPAsyncWebServer` library is powerful and non-blocking, but the code's use of `while` loops and `delay()` for tasks like connecting to WiFi and NTP effectively **froze the microcontroller**. This prevented it from doing anything else and negated the library's primary advantage. It's a classic case of using a powerful tool incorrectly.</p>
                    </div>
                    <div class="border border-green-200 bg-green-50 rounded-lg p-6">
                        <h3 class="text-xl font-semibold text-green-800 flex items-center mb-3">
                            <span class="text-2xl mr-3">✔</span> File 2's Strength
                        </h3>
                        <p class="text-green-700">The `WebServer` library is simpler, but the programmer's decision to use a **state-based, `millis()`-driven approach** allowed the program's main loop to run continuously. This non-blocking methodology ensures all tasks are managed concurrently, leading to a much more stable and responsive system.</p>
                    </div>
                </div>
            </section>
            
            <div class="text-center my-12">
                 <h2 class="text-2xl sm:text-3xl font-bold text-slate-900">Side-by-Side Comparison</h2>
                 <p class="mt-2 text-slate-600">Explore the four key differences in approach below.</p>
            </div>

            <section id="web-server" class="mb-12">
                 <div class="grid md:grid-cols-2 gap-8">
                    <div class="bg-white rounded-xl shadow-md p-6">
                        <h3 class="text-xl font-semibold text-red-800 mb-4">Approach 1: `ESPAsyncWebServer`</h3>
                        <p class="text-slate-600 mb-4">This non-blocking, event-driven library is powerful. Like a modern waiter handling multiple tables at once, it doesn't wait for one task to finish before starting another. However, its benefits were undermined by blocking code elsewhere in the program.</p>
                        <pre class="bg-slate-100 text-slate-800 rounded-md p-4 text-sm overflow-x-auto"><code>// Event-driven handlers are set up once
server.on("/", HTTP_GET, [](AsyncWebServerRequest* request) {
  request->send(200, "text/html", index_html);
});

server.on("/", HTTP_POST, [](AsyncWebServerRequest* request) {
  // Logic to handle form data
});</code></pre>
                    </div>
                     <div class="bg-white rounded-xl shadow-md p-6">
                        <h3 class="text-xl font-semibold text-green-800 mb-4">Approach 2: `WebServer`</h3>
                        <p class="text-slate-600 mb-4">This standard library is simpler but blocking. Like a traditional waiter who serves one table at a time, `server.handleClient()` must be called constantly in the main loop, otherwise the server becomes unresponsive.</p>
                        <pre class="bg-slate-100 text-slate-800 rounded-md p-4 text-sm overflow-x-auto"><code>// Must be called in every loop iteration
void loop() {
  server.handleClient();
  // Other non-blocking code...
}</code></pre>
                    </div>
                </div>
            </section>

            <section id="task-scheduling" class="mb-12">
                 <div class="grid md:grid-cols-2 gap-8">
                    <div class="bg-white rounded-xl shadow-md p-6">
                        <h3 class="text-xl font-semibold text-red-800 mb-4">Approach 1: Blocking with `delay()`</h3>
                        <p class="text-slate-600 mb-4">The code relies on `delay()` and `while` loops that halt the entire program. While waiting for WiFi to connect, the ESP32 can do nothing else—it can't serve web pages or update LEDs. This is known as "blocking" and is highly inefficient.</p>
                        <pre class="bg-slate-100 text-slate-800 rounded-md p-4 text-sm overflow-x-auto"><code>void initWiFi() {
  while (WiFi.status() != WL_CONNECTED) {
    delay(100); // Program is FROZEN here
    // No other tasks can run.
  }
}</code></pre>
                    </div>
                     <div class="bg-white rounded-xl shadow-md p-6">
                        <h3 class="text-xl font-semibold text-green-800 mb-4">Approach 2: Non-Blocking with `millis()`</h3>
                        <p class="text-slate-600 mb-4">This approach avoids `delay()` entirely. It uses `millis()` to check if enough time has passed to perform a task. The main `loop` runs thousands of times per second, ensuring all tasks are managed concurrently and the system remains responsive.</p>
                        <pre class="bg-slate-100 text-slate-800 rounded-md p-4 text-sm overflow-x-auto"><code>void loop() {
  unsigned long currentMillis = millis();
  if (currentMillis - lastCheck >= interval) {
    lastCheck = currentMillis;
    // Perform a non-blocking task...
  }
}</code></pre>
                    </div>
                </div>
            </section>

             <section id="error-handling" class="mb-12">
                 <div class="grid md:grid-cols-2 gap-8">
                    <div class="bg-white rounded-xl shadow-md p-6">
                        <h3 class="text-xl font-semibold text-red-800 mb-4">Approach 1: Restart on Failure</h3>
                        <p class="text-slate-600 mb-4">The error handling is blunt: if a connection fails after a set number of tries, the device reboots with `ESP.restart()`. This is disruptive, causing several seconds of downtime and losing any temporary state.</p>
                        <pre class="bg-slate-100 text-slate-800 rounded-md p-4 text-sm overflow-x-auto"><code>if (numtries > wifitries) {
  numtries = 0;
  ESP.restart(); // Forces a full reboot
}</code></pre>
                    </div>
                     <div class="bg-white rounded-xl shadow-md p-6">
                        <h3 class="text-xl font-semibold text-green-800 mb-4">Approach 2: Graceful Retries</h3>
                        <p class="text-slate-600 mb-4">This method is far more graceful. If the connection is lost, it continuously tries to reconnect in the background while signaling the failure with a visual indicator (blinking LEDs). The rest of the system remains fully operational.</p>
                        <pre class="bg-slate-100 text-slate-800 rounded-md p-4 text-sm overflow-x-auto"><code>if (WiFi.status() != WL_CONNECTED) {
  isWifiConnected = false;
  signalFailure(); // Calls a non-blocking function
}</code></pre>
                    </div>
                </div>
            </section>

            <section id="code-structure" class="mb-12">
                 <div class="grid md:grid-cols-2 gap-8">
                    <div class="bg-white rounded-xl shadow-md p-6">
                        <h3 class="text-xl font-semibold text-red-800 mb-4">Approach 1: Redundant Logic</h3>
                        <p class="text-slate-600 mb-4">The same logic for flashing LEDs is duplicated in multiple functions (`initWiFi()`, `GetLocalTime()`). This makes the code harder to read, maintain, and debug, as a change in one place must be remembered in others.</p>
                        <pre class="bg-slate-100 text-slate-800 rounded-md p-4 text-sm overflow-x-auto"><code>// In GetLocalTime()...
while (!getLocalTime(&timeinfo)) {
  // ... LED flashing code ...
  delay(100);
}
// Same logic exists in initWiFi()</code></pre>
                    </div>
                     <div class="bg-white rounded-xl shadow-md p-6">
                        <h3 class="text-xl font-semibold text-green-800 mb-4">Approach 2: Modular Functions</h3>
                        <p class="text-slate-600 mb-4">The code is broken down into small, reusable, single-purpose functions like `signalFailure()` and `handleRoot()`. This modular approach makes the code clean, easy to understand, and simple to extend with new features.</p>
                        <pre class="bg-slate-100 text-slate-800 rounded-md p-4 text-sm overflow-x-auto"><code>// A reusable, single-purpose function
void signalFailure() {
  // Logic for blinking LEDs
}
// Called from anywhere it's needed</code></pre>
                    </div>
                </div>
            </section>
            
            <section id="visualization" class="bg-white rounded-2xl shadow-lg p-6 sm:p-8 my-10">
                <h2 class="text-2xl sm:text-3xl font-bold text-center text-slate-900 mb-2">Visualizing Concurrency</h2>
                <p class="text-center text-slate-600 mb-8 max-w-4xl mx-auto">This diagram illustrates the "Delay is Death" principle. The blocking loop gets stuck on long tasks, while the non-blocking loop handles multiple tasks concurrently, leading to a responsive system.</p>
                <div class="grid lg:grid-cols-2 gap-8 items-start">
                    <!-- Blocking Visualization -->
                    <div>
                        <h3 class="font-semibold text-center text-red-800 mb-4">❌ Blocking Loop Execution</h3>
                        <div class="relative border-l-2 border-slate-300 pl-6 space-y-4 py-2">
                             <div class="absolute w-3 h-3 bg-slate-400 rounded-full -left-[7px] top-3"></div>
                            <div class="task-block bg-red-100 text-red-800 p-3 rounded-md shadow-sm">
                                <p class="font-medium">Start Loop</p>
                                <p class="text-sm">Begin checking tasks...</p>
                            </div>
                            <div class="task-block bg-red-500 text-white p-3 rounded-md shadow-sm animate-pulse">
                                <p class="font-medium">Attempting WiFi Connect...</p>
                                <p class="text-sm">Program is FROZEN. Waiting for 3 seconds...</p>
                            </div>
                            <div class="task-block bg-slate-200 text-slate-500 p-3 rounded-md shadow-sm opacity-50">
                                <p class="font-medium">Handle Web Request</p>
                                <p class="text-sm">Cannot run. Blocked by WiFi task.</p>
                            </div>
                            <div class="task-block bg-slate-200 text-slate-500 p-3 rounded-md shadow-sm opacity-50">
                                <p class="font-medium">Update LEDs</p>
                                <p class="text-sm">Cannot run. Blocked by WiFi task.</p>
                            </div>
                        </div>
                    </div>
                     <!-- Non-Blocking Visualization -->
                    <div>
                        <h3 class="font-semibold text-center text-green-800 mb-4">✔ Non-Blocking Loop Execution</h3>
                        <div class="relative border-l-2 border-slate-300 pl-6 space-y-4 py-2">
                            <div class="absolute w-3 h-3 bg-slate-400 rounded-full -left-[7px] top-3"></div>
                            <div class="task-block bg-green-100 text-green-800 p-3 rounded-md shadow-sm">
                                <p class="font-medium">Check WiFi Status</p>
                                <p class="text-sm">Is it time? Yes. Check and move on. (1ms)</p>
                            </div>
                            <div class="task-block bg-green-100 text-green-800 p-3 rounded-md shadow-sm">
                                <p class="font-medium">Handle Web Request</p>
                                <p class="text-sm">Any requests? No. Move on. (1ms)</p>
                            </div>
                            <div class="task-block bg-green-100 text-green-800 p-3 rounded-md shadow-sm">
                                <p class="font-medium">Update LEDs</p>
                                <p class="text-sm">Is it time? Yes. Update and move on. (1ms)</p>
                            </div>
                             <div class="task-block bg-green-100 text-green-800 p-3 rounded-md shadow-sm">
                                <p class="font-medium">Check NTP Time</p>
                                <p class="text-sm">Is it time? No. Move on. (1ms)</p>
                            </div>
                            <p class="pt-2 text-center text-slate-500 italic">Loop repeats thousands of times per second.</p>
                        </div>
                    </div>
                </div>
            </section>
        </main>

        <footer class="text-center mt-12 mb-6">
            <p class="text-slate-500">This interactive analysis demonstrates that a non-blocking methodology is key to creating robust and responsive embedded applications.</p>
        </footer>

    </div>

</body>
</html>

